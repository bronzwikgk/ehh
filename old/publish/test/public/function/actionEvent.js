
/**
 * ActionEvent is a class that acts like an inbox for events.
 * working on pub/sub design pattern, it listens to an array of events on a live object.
 * It's primar job is to create listeners on an object, and trigger a message to other service worker to handle an event.
 * To use create a new instance of the ActionEvent while providing arguements
 *      	object || entit to listen on
 *          array of listeners (in case this is not present, it listens to all the events)
 *  Controller Instance. A reference(name) of the controller instance is passed to let actionEVent know where to send the message.
 * 
 * ActionSpace App, creates a run time instance of it using, new ActionEvent(window,all)		
 */


 /**
  * Vairables
  *         ActiveListnerArray : 	a runtime variable that stores the active Listners created in a runtime instance.
  *         entity	: object to listen on
  *         ActionEventInstance	: 
  *         callback
  *         event	The Event interface represents an event which takes place in the DOM.
  *                 "An event can be triggered by the user action e.g. clicking the mouse button or tapping keyboard, or generated by APIs to represent the progress of an asynchronous task.
  *                    It can also be triggered programmatically, such as by calling the HTMLElement.click() method of an element, or by defining the event, then sending it to a specified target using EventTarget.dispatchEvent()."
  *         Event.currentTarget	The currentTarget read-only property of the Event interface identifies the current target for the event, as the event traverses the DOM. It always refers to the element to which the event handler has been attached, as opposed to Event.target, which identifies the element on which the event occurred and which may be its descendant.
                                Syntax
                                var currentEventTarget = event.currentTarget
     
  */

class ActionEvent {
    /**
     * Creates ActionEvent Instance
     * @param {HTMLObjectElement} entity the entity on which all events will be listened
     * @param {Array} events a list of events, if not present, this instance will listen to all events
     */
    constructor(entity, events) {
        console.log("here");
        this.entity = entity;
        this.listeners = events || [];
        this.addAllListeners(this.listen.bind(this), (events)?false:true);
    }
    /**
     * Acts as a listener function for all the events and passes the event type and object to this.emit
     * @param {Event} e 
     */
    listen(e) {
        if (this.listeners.indexOf(e.type) > 0) {
            this.emit(e.type, e);
        }
    }
    /**
     * Messages controller about the events happening with ...args as arguments
     * @param {Array} events
     * @param {...any} args
     */
    emit(events, ...args) {
        if (operate.isString(events)) events = [events];
        events.forEach(function (event) {
            //message controller here
            controller.handleEvent(event, ...args);
        });
    }
    /**
     * Adds listener to the instance
     * @param {any} events
     */
    addListener(events) {
        if (operate.isString(events)) events = [events];
        events.forEach(function (event) {
            if (this.listeners.indexOf(event) < 0) {
                this.listeners.push(event);
                this.entity.addEventListener(event, listen.bind(this));
            }
        });

    }
    /**
     * Removes listeners from active listeners
     * @param {any} events 
     */
    removeListener(events) {
        if (operate.isString(events)) events = [events];
        events.forEach(function (event) {
            if (this.listeners.indexOf(event) < 0) return;
            this.listeners.splice(this.listeners.indexOf(event), 1);
        });
    }
    /**
     * Adds all event listener, with `listener` as listener function and `...otherArguments` as other parameters
     * @param {Function} listener
     * @param {...any} otherArguments
     */
    addAllListeners(listener, pushToListener, ...otherArguments) {
        var target = this.entity;
        // install listeners for all natively triggered events
        for (const key in target) {
            if (/^on/.test(key)) {
                const eventType = key.substr(2);
                target.addEventListener(eventType, listener, ...otherArguments);
                if (pushToListener) { this.listeners.push(eventType); }
            }
        }
        /*
                // dynamically install listeners for all manually triggered events, just-in-time before they're dispatched ;D
                const dispatchEvent_original = EventTarget.prototype.dispatchEvent;
                function dispatchEvent(event) {
                    target.addEventListener(event.type, listener, ...otherArguments);  // multiple identical listeners are automatically discarded
                    dispatchEvent_original.apply(this, arguments);
                }   
                EventTarget.prototype.dispatchEvent = dispatchEvent;
                if (EventTarget.prototype.dispatchEvent !== dispatchEvent) throw new Error(`Browser is smarter than you think!`);
        */
    }
}
export { ActionEvent };

/**
 * connection.addListener(event, listener)

connection.on(event, listener)

connection.once(event, listener)

connection.removeListener(event, listener)

connection.removeAllListeners([event])

connection.setMaxListeners(n)

connection.listeners(event)

connection.emit(event, [arg1], [arg2], [...])
 */